# 防抖

## 定义

防抖(debounce)的定义: debounce - 去抖动，防抖是指在一段时间内，多次触发同一事件，只执行最后一次操作，其他操作被忽略(事件再次发生时重新计时)

## 应用场景

应用场景:

1. Select 下拉选择(用户在输入的时候，其实是不应该请求的)

# 节流

## 定义

节流(throttled)的定义: throttled - 节流，在一段时间内，多次触发同一事件，只执行一次操作，停止之后还会继续触发一次

## 应用场景

应用场景:

1. 搜索结果页面的触底加载判断(如果使用防抖的话，就不能达到预加载的目的了)

# 使用 lodash 来实现防抖节流

Q: 在 lodash 的 throttle, debounce 函数中, 为什么要定义 leading, trailing 这个两个备选参数?
A:
leading: 表示是否立即调用？
trailing: 是否进行最后一次调用, true 表示调用, false 表示不调用

对于这两个参数, 我们不妨想象一下下面两个场景

1. 页面滚动时, 要求立即触发一次滚动的回调
2. 页面滚动时, 滚动完成需要触发一个滚动的回到(这个事件浏览器是没有提供, 而对于 scroll 事件, 由于其触发得太频繁, 我们需要对其进行限流工作)

而 leading, trailing 这两个参数正好能够解决上面这两个问题

[Lodash\_节流](./demo/3_%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/Lodash_%E8%8A%82%E6%B5%81.html)
[Lodash\_防抖](./demo/3_%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/Lodash_%E9%98%B2%E6%8A%96.html)

# 原理剖析-自定防抖节流函数

[防抖](../code/防抖.html)
[节流](../code/节流.html)
[utils](../code/utils.js)

# 在 React 框架中使用防抖节流

**由于 React 的特性：每次组件的更新都会默认所有的对象都会返回一个全新的值；而我们的防抖节流需要使用到闭包中的缓存，不能强制刷新，刷新之后就失去作用了；因此 React 中使用防抖和节流需要特殊处理一下，即使用 useMemo/useCallback 修饰一下**
[React 中的防抖和节流](./demo/3_%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/React%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81.html)

**但是如果使用 useMemo/useCallback 修饰的话，同时也会出现新的问题，我们在 防抖/回流 的回调函数中将不能够正常访问 state, 如果我们需要访问 state 的话，需要做一下特殊的处理，即将 state 的状态同步到 ref 对象中去**
[React 中的防抖和节流中访问 state](./demo/3_%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/React%E4%B8%AD%E7%9A%84%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E4%B8%AD%E8%AE%BF%E9%97%AEstate.html)

# 业务场景思考-搜索结果页面

对于搜索结果页的下拉刷新场景，一般我们要求滑动到 80% 就自动加载下一页；
针对这个业务逻辑，此时使用节流比防抖效果要好，因为如果使用了防抖的话，如果用户在一直滑动页面的话，我们将很难实现预加载

# 注意点

1. 再具体业务中，推荐还是使用 lodash 库来完成防抖和节流的操作

# 参考链接

1. [lodashjs - \_throttlefunc](https://www.lodashjs.com/docs/lodash.throttle#_throttlefunc-wait0-options)
